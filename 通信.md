

## 进程通信

### 管道

内核的一块内存空间.
字节流，没有边界，半双工（数据流只能向一个方向）
多对多通信：需要多个管道。
大小： 4-6kb
### 消息队列

内核中的一块内存控件（链表数据结构）。
全双工通信，有边界，可以自定义消息结构。
多对多通信：1个消息队列支持。
大小：可以系统修改。

**两者的共同：**
阻塞


**两者的区别：**
​​维度​​	​​管道​​	​​消息队列​​
​​速度​​	更高（内核缓冲区直接拷贝）	略低（需处理消息结构）
​​开发复杂度​​	简单（仅文件描述符操作）	较高（需管理键值、类型等）
​​扩展性​​	差（难以支持复杂通信模式）	强（支持多对多、优先级等）

**总结​​**   
​​选择管道​​：当需要简单、高效的​​字节流​​通信，且进程关系紧密（如父子进程）。
​​选择消息队列​​：当需要​​结构化消息​​、无关进程通信、或持久化支持。





## Javascript引擎

### js引擎的本质 

JavaScript 引擎的本质是一个​​将 JavaScript 代码转换为可执行指令的虚拟机​​，其核心目标是高效地解析、编译并运行 JS 代码。  

跨平台的本质：字节码(平台无关，16进制编码)，通过 虚拟机/解释器 翻译为 机器码（运行在不同CPU架构的机器上）。  

#### 原理
结合了 ​​解释执行（Interpreter）​​ 和 ​​即时编译（JIT, Just-In-Time Compilation）​​ 技术。
**解释：**
词法分析、转AST。
V8 的 ​​Ignition​​ 解释器将 AST 转换为 ​​字节码（Bytecode）。


**JIT** 
a.编译字节码 为 机器码  
b.热点代码，高度优化 机器码  
c.运行时类型变化（如 number 突然变成 string），回退到解释器或重新编译


#### c++与js通信

你还可以将 C++ 函数、对象和类绑定到 JavaScript 环境中，让 JavaScript 可以创建和操作这些对象。  
一般来说，这个通信过程是同步的，是在一个主线程执行。
这中间带来的性能损耗 ：



          
C++ 和 JavaScript 通信时，时间损耗主要体现在以下几个方面：

##### 1. 数据类型转换
C++ 和 JavaScript 有各自不同的数据类型系统。在两者通信时，需要将数据从一种类型系统转换到另一种类型系统，这个过程会带来时间损耗。

- **C++ 到 JavaScript**：例如，C++ 中的 `std::string` 类型需要转换为 JavaScript 中的字符串类型。如果是复杂的数据结构，如 C++ 中的结构体或类，转换过程会更加复杂。
- **JavaScript 到 C++**：JavaScript 中的对象或数组需要转换为 C++ 能够理解的数据结构，这可能涉及到递归解析和内存分配。

##### 2. 上下文切换
当在 C++ 和 JavaScript 之间进行通信时，可能需要在不同的执行上下文之间进行切换。例如，在使用 V8 引擎时，C++ 代码运行在本地环境中，而 JavaScript 代码运行在 V8 引擎的隔离环境中。切换上下文需要保存和恢复执行状态，这会消耗一定的时间。

##### 3. 内存管理
C++ 和 JavaScript 有不同的内存管理机制。C++ 通常需要手动管理内存，而 JavaScript 使用垃圾回收机制。在两者通信时，需要确保数据在不同的内存管理机制之间正确传递，避免内存泄漏或悬空指针等问题。这个过程可能会涉及到额外的内存分配和释放操作，从而带来时间损耗。

##### 4. 调用栈管理
每次从 C++ 调用 JavaScript 函数或从 JavaScript 调用 C++ 函数时，都需要管理调用栈。这包括保存当前的调用栈状态、创建新的调用栈帧以及恢复调用栈状态。调用栈的管理会带来一定的时间开销，尤其是在频繁进行函数调用时。

##### 5. 异步操作处理
如果使用异步方式进行通信，如使用回调函数或 Promise，需要处理异步操作的调度和同步问题。这可能涉及到事件循环、线程池等机制，会增加通信的时间损耗。

综上所述，C++ 和 JavaScript 通信时的时间损耗主要来自数据类型转换、上下文切换、内存管理、调用栈管理和异步操作处理等方面。在实际开发中，可以通过优化数据传输格式、减少不必要的函数调用和合理使用异步操作等方式来降低时间损耗。 

        


